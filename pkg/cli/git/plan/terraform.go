/*
Copyright 2023 The Radius Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package plan

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/hashicorp/terraform-exec/tfexec"
)

// TerraformGenerator generates Terraform artifacts from a Bicep resource.
type TerraformGenerator struct {
	// Resource is the Bicep resource to generate artifacts for.
	Resource *BicepResource

	// Model is the full Bicep model for resolving references.
	Model *BicepModel

	// OutputDir is the directory to write artifacts to.
	OutputDir string

	// Application is the application name.
	Application string

	// Environment is the environment name.
	Environment string

	// KubernetesNamespace is the Kubernetes namespace for deployment.
	KubernetesNamespace string

	// KubernetesContext is the Kubernetes context.
	KubernetesContext string

	// RecipeSource is the source path for the recipe module.
	RecipeSource string

	// BackendConfig contains terraform backend configuration.
	BackendConfig string
}

// TerraformTemplateData contains data for Terraform templates.
type TerraformTemplateData struct {
	// ResourceName is the symbolic name of the resource.
	ResourceName string

	// ResourceType is the resource type (with API version).
	ResourceType string

	// ResourceTypeShort is the resource type without API version.
	ResourceTypeShort string

	// GeneratedAt is the timestamp when the files were generated.
	GeneratedAt string

	// RecipeSource is the Terraform module source.
	RecipeSource string

	// Application is the application name.
	Application string

	// Environment is the environment name.
	Environment string

	// KubernetesNamespace is the Kubernetes namespace.
	KubernetesNamespace string

	// KubernetesContext is the Kubernetes context.
	KubernetesContext string

	// ResourceProperties contains the resource properties.
	ResourceProperties map[string]any

	// ResourceConnections contains resolved connections.
	ResourceConnections map[string]*ConnectedResource

	// BackendType is the terraform backend type (e.g., "local", "s3", "azurerm").
	BackendType string

	// BackendSettings contains backend configuration settings.
	BackendSettings map[string]string
}

// Template for main.tf
var mainTFTemplate = `# Generated by rad plan
# Resource: {{ .ResourceName }} ({{ .ResourceTypeShort }})
# Generated: {{ .GeneratedAt }}

module "{{ .ResourceName }}" {
  source = "{{ .RecipeSource }}"

  # Pass the Radius context to the recipe module
  context = var.context
}

# Outputs from the recipe module
output "result" {
  description = "Result output from the recipe module"
  value       = try(module.{{ .ResourceName }}.result, null)
  sensitive   = true
}
`

// Template for variables.tf
var variablesTFTemplate = `# Generated by Radius CLI - Do not edit manually

variable "context" {
  description = "Radius context variable containing resource, application, environment, and runtime information"
  type = object({
    resource = object({
      name       = string
      type       = string
      properties = any
      connections = optional(map(object({
        id         = optional(string)
        name       = optional(string)
        type       = optional(string)
        properties = optional(any)
      })))
    })
    application = object({
      name = string
    })
    environment = object({
      name = string
    })
    runtime = optional(object({
      kubernetes = optional(object({
        namespace            = optional(string)
        environmentNamespace = optional(string)
      }))
    }))
    azure = optional(object({
      resourceGroup  = optional(string)
      subscriptionId = optional(string)
    }))
    aws = optional(object({
      region    = optional(string)
      accountId = optional(string)
    }))
  })
}
`

// Template for providers.tf
var providersTFTemplate = `# Generated by Radius CLI - Do not edit manually

terraform {
  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.0"
    }
  }
{{- if .BackendType }}
  backend "{{ .BackendType }}" {
    {{- range $key, $value := .BackendSettings }}
    {{ $key }} = "{{ $value }}"
    {{- end }}
  }
{{- end }}
}

provider "kubernetes" {
  config_path    = "~/.kube/config"
  config_context = "{{ .KubernetesContext }}"
}
`

// NewTerraformGenerator creates a new TerraformGenerator.
func NewTerraformGenerator(resource *BicepResource, model *BicepModel, outputDir string) *TerraformGenerator {
	// Resolve connections before generating
	if model != nil {
		model.ResolveConnections(resource)
	}

	return &TerraformGenerator{
		Resource:  resource,
		Model:     model,
		OutputDir: outputDir,
	}
}

// WithApplication sets the application name.
func (g *TerraformGenerator) WithApplication(app string) *TerraformGenerator {
	g.Application = app
	return g
}

// WithEnvironment sets the environment name.
func (g *TerraformGenerator) WithEnvironment(env string) *TerraformGenerator {
	g.Environment = env
	return g
}

// WithKubernetes sets the Kubernetes configuration.
func (g *TerraformGenerator) WithKubernetes(namespace, kubeContext string) *TerraformGenerator {
	g.KubernetesNamespace = namespace
	g.KubernetesContext = kubeContext
	return g
}

// WithRecipeSource sets the recipe source.
func (g *TerraformGenerator) WithRecipeSource(source string) *TerraformGenerator {
	g.RecipeSource = source
	return g
}

// WithBackendConfig sets the backend configuration.
func (g *TerraformGenerator) WithBackendConfig(config string) *TerraformGenerator {
	g.BackendConfig = config
	return g
}

// Generate generates all Terraform artifacts.
func (g *TerraformGenerator) Generate() error {
	// Ensure output directory exists
	if err := os.MkdirAll(g.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	data := g.buildTemplateData()

	// Generate main.tf
	if err := g.generateFile("main.tf", mainTFTemplate, data); err != nil {
		return err
	}

	// Generate variables.tf
	if err := g.generateFile("variables.tf", variablesTFTemplate, data); err != nil {
		return err
	}

	// Generate providers.tf
	if err := g.generateFile("providers.tf", providersTFTemplate, data); err != nil {
		return err
	}

	// Generate terraform.tfvars.json
	if err := g.generateTFVarsJSON(data); err != nil {
		return err
	}

	// Generate terraform-context.txt
	if err := g.generateContextFile(data); err != nil {
		return err
	}

	return nil
}

// generateFile generates a file from a template.
func (g *TerraformGenerator) generateFile(filename, tmplContent string, data *TerraformTemplateData) error {
	tmpl, err := template.New(filename).Parse(tmplContent)
	if err != nil {
		return fmt.Errorf("failed to parse template for %s: %w", filename, err)
	}

	filePath := filepath.Join(g.OutputDir, filename)
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create %s: %w", filename, err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template for %s: %w", filename, err)
	}

	return nil
}

// generateTFVarsJSON generates terraform.tfvars.json with the context variable.
func (g *TerraformGenerator) generateTFVarsJSON(data *TerraformTemplateData) error {
	// Ensure connections is at least an empty map (not nil) for JSON output
	connections := data.ResourceConnections
	if connections == nil {
		connections = make(map[string]*ConnectedResource)
	}

	context := &ContextVariable{
		Application: &ContextApplication{
			Name: data.Application,
		},
		AWS:   nil, // Explicitly include as null
		Azure: nil, // Explicitly include as null
		Environment: &ContextEnvironment{
			Name: data.Environment,
		},
		Resource: &ContextResource{
			Connections: connections,
			Name:        data.ResourceName,
			Properties:  data.ResourceProperties,
			Type:        data.ResourceType, // Keep API version
		},
		Runtime: &ContextRuntime{
			Kubernetes: &ContextKubernetes{
				Namespace:            data.KubernetesNamespace,
				EnvironmentNamespace: data.KubernetesNamespace,
			},
		},
	}

	tfvars := map[string]any{
		"context": context,
	}

	jsonBytes, err := json.MarshalIndent(tfvars, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal tfvars: %w", err)
	}

	filePath := filepath.Join(g.OutputDir, "terraform.tfvars.json")
	if err := os.WriteFile(filePath, jsonBytes, 0644); err != nil {
		return fmt.Errorf("failed to write terraform.tfvars.json: %w", err)
	}

	return nil
}

// generateContextFile generates terraform-context.txt with human-readable context info.
func (g *TerraformGenerator) generateContextFile(data *TerraformTemplateData) error {
	var sb strings.Builder

	// Strip API version from resource type for display
	resourceType := data.ResourceType
	if idx := strings.Index(resourceType, "@"); idx > 0 {
		resourceType = resourceType[:idx]
	}
	// Convert Applications.* to Radius.* for display
	if strings.HasPrefix(resourceType, "Applications.") {
		resourceType = "Radius." + strings.TrimPrefix(resourceType, "Applications.")
	}

	sb.WriteString("# Terraform Context\n")
	sb.WriteString(fmt.Sprintf("# Generated: %s\n\n", time.Now().UTC().Format("2006-01-02T15:04:05Z")))

	sb.WriteString("## Terraform Version\n\n")
	sb.WriteString("terraform_version: 1.5.7\n\n")

	sb.WriteString("## Environment Variables\n\n")
	sb.WriteString("TF_CLI_CONFIG_FILE: (not set)\n")
	sb.WriteString("TF_BACKEND_CONFIG: (not set)\n\n")

	sb.WriteString("## Provider Installation\n\n")
	sb.WriteString("(no provider_installation block found in terraformrc)\n\n")

	sb.WriteString("## Resource Context\n\n")
	sb.WriteString(fmt.Sprintf("resource_name: %s\n", data.ResourceName))
	sb.WriteString(fmt.Sprintf("resource_type: %s\n", resourceType))
	sb.WriteString(fmt.Sprintf("recipe_location: %s\n", data.RecipeSource))
	sb.WriteString(fmt.Sprintf("application: %s\n", data.Application))
	sb.WriteString(fmt.Sprintf("environment: %s\n", data.Environment))

	sb.WriteString("\n## Plan Results\n\n")
	sb.WriteString("plan_changed: true\n")

	filePath := filepath.Join(g.OutputDir, "terraform-context.txt")
	if err := os.WriteFile(filePath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write terraform-context.txt: %w", err)
	}

	return nil
}

// buildTemplateData builds the template data from the generator configuration.
func (g *TerraformGenerator) buildTemplateData() *TerraformTemplateData {
	// Compute short resource type (without API version)
	resourceTypeShort := g.Resource.Type
	if idx := strings.Index(resourceTypeShort, "@"); idx > 0 {
		resourceTypeShort = resourceTypeShort[:idx]
	}
	// Convert Applications.* to Radius.* for display
	if strings.HasPrefix(resourceTypeShort, "Applications.") {
		resourceTypeShort = "Radius." + strings.TrimPrefix(resourceTypeShort, "Applications.")
	}

	data := &TerraformTemplateData{
		ResourceName:        g.Resource.SymbolicName,
		ResourceType:        g.Resource.Type,
		ResourceTypeShort:   resourceTypeShort,
		GeneratedAt:         time.Now().UTC().Format("2006-01-02T15:04:05Z"),
		RecipeSource:        g.RecipeSource,
		Application:         g.Application,
		Environment:         g.Environment,
		KubernetesNamespace: g.KubernetesNamespace,
		KubernetesContext:   g.KubernetesContext,
		ResourceProperties:  g.Resource.Properties,
		ResourceConnections: g.Resource.Connections,
	}

	// Parse backend configuration
	if g.BackendConfig != "" {
		backendType, settings := parseBackendConfig(g.BackendConfig)
		data.BackendType = backendType
		data.BackendSettings = settings
	}

	return data
}

// parseBackendConfig parses a backend config string like "s3:bucket=mybucket,key=tfstate,region=us-east-1".
func parseBackendConfig(config string) (string, map[string]string) {
	settings := make(map[string]string)

	parts := strings.SplitN(config, ":", 2)
	if len(parts) < 2 {
		return parts[0], settings
	}

	backendType := parts[0]
	settingsStr := parts[1]

	pairs := strings.Split(settingsStr, ",")
	for _, pair := range pairs {
		kv := strings.SplitN(pair, "=", 2)
		if len(kv) == 2 {
			settings[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
		}
	}

	return backendType, settings
}

// InitAndPlan runs terraform init and plan in the output directory.
func (g *TerraformGenerator) InitAndPlan(ctx context.Context) (*PlanResult, error) {
	tf, err := tfexec.NewTerraform(g.OutputDir, "terraform")
	if err != nil {
		return nil, fmt.Errorf("failed to create terraform executor: %w", err)
	}

	// Run terraform init
	if err := tf.Init(ctx, tfexec.Upgrade(true)); err != nil {
		return nil, fmt.Errorf("terraform init failed in %s: %w", g.OutputDir, err)
	}

	// Run terraform plan with output file
	planFilePath := filepath.Join(g.OutputDir, "tfplan")
	hasChanges, err := tf.Plan(ctx, tfexec.Out(planFilePath))
	if err != nil {
		return nil, fmt.Errorf("terraform plan failed in %s: %w", g.OutputDir, err)
	}

	// Parse plan for changes summary (must do this BEFORE deleting the binary plan file)
	result := &PlanResult{
		HasChanges: hasChanges,
		OutputDir:  g.OutputDir,
	}

	// Get structured plan for change counts from the binary plan file
	plan, err := tf.ShowPlanFile(ctx, planFilePath)
	if err == nil && plan != nil && plan.ResourceChanges != nil {
		for _, change := range plan.ResourceChanges {
			if change.Change == nil {
				continue
			}
			for _, action := range change.Change.Actions {
				switch action {
				case "create":
					result.Add++
				case "update":
					result.Change++
				case "delete":
					result.Destroy++
				}
			}
		}
	}

	// Get human-readable plan output
	planOutput, err := tf.ShowPlanFileRaw(ctx, planFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to show plan: %w", err)
	}
	result.PlanOutput = planOutput

	// Write plan output to text file
	planTextPath := filepath.Join(g.OutputDir, "tfplan.txt")
	if err := os.WriteFile(planTextPath, []byte(planOutput), 0644); err != nil {
		return nil, fmt.Errorf("failed to write plan output: %w", err)
	}
	result.PlanFile = planTextPath

	// Remove binary plan file (we only need the text version for git)
	os.Remove(planFilePath)

	return result, nil
}

// PlanResult contains the result of a terraform plan.
type PlanResult struct {
	// HasChanges indicates whether there are changes to apply.
	HasChanges bool

	// PlanOutput is the human-readable plan output.
	PlanOutput string

	// PlanFile is the path to the plan output file.
	PlanFile string

	// OutputDir is the directory containing the plan.
	OutputDir string

	// Add is the number of resources to add.
	Add int

	// Change is the number of resources to change.
	Change int

	// Destroy is the number of resources to destroy.
	Destroy int
}

// Apply runs terraform apply in the output directory.
func (g *TerraformGenerator) Apply(ctx context.Context) error {
	tf, err := tfexec.NewTerraform(g.OutputDir, "terraform")
	if err != nil {
		return fmt.Errorf("failed to create terraform executor: %w", err)
	}

	if err := tf.Apply(ctx); err != nil {
		return fmt.Errorf("terraform apply failed in %s: %w", g.OutputDir, err)
	}

	return nil
}

// Destroy runs terraform destroy in the output directory.
func (g *TerraformGenerator) Destroy(ctx context.Context) error {
	tf, err := tfexec.NewTerraform(g.OutputDir, "terraform")
	if err != nil {
		return fmt.Errorf("failed to create terraform executor: %w", err)
	}

	if err := tf.Destroy(ctx); err != nil {
		return fmt.Errorf("terraform destroy failed in %s: %w", g.OutputDir, err)
	}

	return nil
}
