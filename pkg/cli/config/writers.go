/*
Copyright 2023 The Radius Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// WriteTypesManifestWithHeader writes a types.yaml file to the .radius directory with header.
func WriteTypesManifestWithHeader(radiusDir string, manifest *ResourceTypesManifest) error {
	data, err := yaml.Marshal(manifest)
	if err != nil {
		return fmt.Errorf("failed to marshal types manifest: %w", err)
	}

	// Add header comment
	header := "# Radius resource types configuration\n# Generated by rad init\n\n"
	data = append([]byte(header), data...)

	typesPath := filepath.Join(radiusDir, "types.yaml")
	if err := os.WriteFile(typesPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write types.yaml: %w", err)
	}

	return nil
}

// WriteRecipesManifestWithHeader writes a recipes.yaml file to the .radius directory with header.
func WriteRecipesManifestWithHeader(radiusDir string, manifest *RecipesManifest) error {
	data, err := yaml.Marshal(manifest)
	if err != nil {
		return fmt.Errorf("failed to marshal recipes manifest: %w", err)
	}

	// Add header comment
	header := "# Radius recipes configuration\n# Generated by rad init\n\n"
	data = append([]byte(header), data...)

	recipesPath := filepath.Join(radiusDir, "recipes.yaml")
	if err := os.WriteFile(recipesPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write recipes.yaml: %w", err)
	}

	return nil
}

// WriteEnvironmentWithHeader writes an environment file to the .radius directory with header.
func WriteEnvironmentWithHeader(radiusDir string, env *Environment) error {
	data, err := yaml.Marshal(env)
	if err != nil {
		return fmt.Errorf("failed to marshal environment: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# Radius environment configuration for %s\n# Generated by rad init\n\n", env.Name)
	data = append([]byte(header), data...)

	envPath := filepath.Join(radiusDir, fmt.Sprintf("env.%s.yaml", env.Name))
	if err := os.WriteFile(envPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write environment file: %w", err)
	}

	return nil
}

// WriteDeploymentPlanFile writes a deployment plan to the .radius/plan directory.
func WriteDeploymentPlanFile(radiusDir string, plan *DeploymentPlan) error {
	// Create plan subdirectory with environment/application hierarchy
	planDir := filepath.Join(radiusDir, "plan", plan.Environment, plan.Application)
	if err := os.MkdirAll(planDir, 0755); err != nil {
		return fmt.Errorf("failed to create plan directory: %w", err)
	}

	data, err := yaml.Marshal(plan)
	if err != nil {
		return fmt.Errorf("failed to marshal deployment plan: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# Deployment plan for %s/%s\n\n",
		plan.Environment, plan.Application)
	data = append([]byte(header), data...)

	planPath := filepath.Join(planDir, "plan.yaml")
	if err := os.WriteFile(planPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write plan.yaml: %w", err)
	}

	return nil
}

// WriteDeploymentRecordFile writes a deployment record to the .radius/deploy directory.
func WriteDeploymentRecordFile(radiusDir string, record *DeploymentRecord) error {
	// Create deploy subdirectory
	deployDir := filepath.Join(radiusDir, "deploy", record.Environment.Name, record.Application)
	if err := os.MkdirAll(deployDir, 0755); err != nil {
		return fmt.Errorf("failed to create deploy directory: %w", err)
	}

	data, err := yaml.Marshal(record)
	if err != nil {
		return fmt.Errorf("failed to marshal deployment record: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# Deployment record for %s/%s\n# Completed at: %s\n\n",
		record.Environment.Name, record.Application, record.CompletedAt.Format("2006-01-02T15:04:05Z07:00"))
	data = append([]byte(header), data...)

	recordPath := filepath.Join(deployDir, "record.yaml")
	if err := os.WriteFile(recordPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write record.yaml: %w", err)
	}

	return nil
}

// ListEnvironments lists all environment files in the .radius directory.
func ListEnvironments(radiusDir string) ([]string, error) {
	pattern := filepath.Join(radiusDir, "env.*.yaml")
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return nil, fmt.Errorf("failed to list environments: %w", err)
	}

	var names []string
	for _, match := range matches {
		base := filepath.Base(match)
		// Extract name from "env.{name}.yaml"
		name := base[4 : len(base)-5] // Remove "env." prefix and ".yaml" suffix
		names = append(names, name)
	}

	return names, nil
}

// ResourceTypesVersion is the version of the resource-types-contrib repo.
// Note: Neither type definitions nor recipe locations include version tags.
// Version pinning for types and recipes is tracked as a future enhancement.
// This constant is retained for potential future use.
const ResourceTypesVersion = "v0.54.0"

// DefaultTypesManifest creates a default types manifest conforming to Appendix C.1.
// This is used as a fallback when resource types cannot be fetched.
// Note: Definition locations do not include version tags per spec (versioning is a future enhancement).
func DefaultTypesManifest() *ResourceTypesManifest {
	return &ResourceTypesManifest{
		Types: map[string]ResourceTypeEntry{
			"Radius.Core/applications": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Core/applications/applications.yaml",
			},
			"Radius.Compute/containers": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Compute/containers/container.yaml",
			},
			"Radius.Compute/persistentVolumes": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Compute/persistentVolumes/persistentVolumes.yaml",
			},
			"Radius.Compute/routes": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Compute/routes/routes.yaml",
			},
			"Radius.Security/secrets": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Security/secrets/secrets.yaml",
			},
			"Radius.Data/mySqlDatabases": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Data/mySqlDatabases/mySqlDatabases.yaml",
			},
			"Radius.Data/postgreSqlDatabases": {
				DefinitionLocation: "git::https://github.com/radius-project/resource-types-contrib.git//Data/postgreSqlDatabases/postgreSqlDatabases.yaml",
			},
		},
	}
}

// FetchedResourceType represents a resource type fetched from the contrib repository.
type FetchedResourceType struct {
	// Type is the fully qualified resource type name.
	Type string

	// Name is the short name of the resource type.
	Name string

	// Namespace is the resource type namespace (e.g., "Radius.Compute").
	Namespace string

	// RelativePath is the path in the repository to the type definition.
	RelativePath string
}

// TypesManifestFromFetched creates a types manifest from fetched resource types.
// This implements FR-008: populate types.yaml from resource-types-contrib.
// TypesManifestFromFetched creates a types manifest from fetched resource types.
// This implements FR-008: populate types.yaml from resource-types-contrib.
// Note: Definition locations do not include version tags per spec (versioning is a future enhancement).
func TypesManifestFromFetched(types []FetchedResourceType) *ResourceTypesManifest {
	manifest := &ResourceTypesManifest{
		Types: make(map[string]ResourceTypeEntry),
	}

	for _, rt := range types {
		// Build the full type name (e.g., "Radius.Compute/containers")
		fullType := rt.Type
		if fullType == "" && rt.Namespace != "" && rt.Name != "" {
			fullType = fmt.Sprintf("%s/%s", rt.Namespace, rt.Name)
		}

		if fullType == "" {
			continue
		}

		// Build the definition location URL (no version tag per spec)
		// Format: git::https://github.com/radius-project/resource-types-contrib.git//Path/to/file.yaml
		defLocation := fmt.Sprintf("git::https://github.com/radius-project/resource-types-contrib.git//%s",
			rt.RelativePath)

		manifest.Types[fullType] = ResourceTypeEntry{
			DefinitionLocation: defLocation,
		}
	}

	return manifest
}

// typesWithoutRecipes lists resource types that are metadata-only and don't have recipes.
var typesWithoutRecipes = map[string]bool{
	"Radius.Core/applications": true,
}

// RecipesManifestFromTypes creates a recipes manifest from a types manifest.
// This implements FR-009-A: include a recipe entry for every resource type in types.yaml
// that has a recipes directory in the repository.
// Note: Recipe locations do not include version tags (versioning is a future enhancement).
func RecipesManifestFromTypes(types *ResourceTypesManifest, provider, deploymentTool string) *RecipesManifest {
	manifest := &RecipesManifest{
		Recipes: map[string]RecipeEntry{},
	}

	recipeKind := RecipeKindTerraform
	if deploymentTool == "bicep" {
		recipeKind = RecipeKindBicep
	}

	for typeName, typeEntry := range types.Types {
		// Skip types that don't have recipes (metadata-only types)
		if typesWithoutRecipes[typeName] {
			continue
		}

		// Extract path from definition location
		// e.g., "git::https://github.com/radius-project/resource-types-contrib.git//Compute/containers/container.yaml"
		// -> "Compute/containers"
		basePath := extractTypeBasePath(typeEntry.DefinitionLocation)
		if basePath == "" {
			continue
		}

		var recipeLocation string
		if deploymentTool == "terraform" {
			// Format: git::https://github.com/radius-project/resource-types-contrib.git//Compute/containers/recipes/aws/terraform
			// Note: Version tags are a future enhancement
			recipeLocation = fmt.Sprintf("git::https://github.com/radius-project/resource-types-contrib.git//%s/recipes/%s/terraform",
				basePath, provider)
		} else if deploymentTool == "bicep" {
			// Format: https://ghcr.io/radius-project/recipes/azure/containers
			// Note: Version tags are a future enhancement
			shortName := extractTypeShortName(typeName)
			recipeLocation = fmt.Sprintf("https://ghcr.io/radius-project/recipes/%s/%s",
				provider, shortName)
		}

		manifest.Recipes[typeName] = RecipeEntry{
			RecipeKind:     recipeKind,
			RecipeLocation: recipeLocation,
		}
	}

	return manifest
}

// extractTypeBasePath extracts the base path from a definition location URL.
// e.g., "git::https://github.com/radius-project/resource-types-contrib.git//Compute/containers/container.yaml"
// -> "Compute/containers"
func extractTypeBasePath(definitionLocation string) string {
	// Find the ".git//" separator which marks the repo path boundary
	const separator = ".git//"
	idx := strings.Index(definitionLocation, separator)
	if idx == -1 {
		return ""
	}

	path := definitionLocation[idx+len(separator):]

	// Remove the filename (e.g., "container.yaml")
	lastSlash := strings.LastIndex(path, "/")
	if lastSlash == -1 {
		return ""
	}

	return path[:lastSlash]
}

// extractTypeShortName extracts the short name from a fully qualified type name.
// e.g., "Radius.Compute/containers" -> "containers"
func extractTypeShortName(typeName string) string {
	idx := strings.LastIndex(typeName, "/")
	if idx == -1 {
		return typeName
	}
	return typeName[idx+1:]
}

// DefaultRecipesManifest creates a default recipes manifest for a given provider and tool.
// This creates recipes based on the default types manifest per FR-009-A.
func DefaultRecipesManifest(provider, deploymentTool string) *RecipesManifest {
	return RecipesManifestFromTypes(DefaultTypesManifest(), provider, deploymentTool)
}

// DefaultEnvironment creates a default environment configuration.
func DefaultEnvironment(name, provider string) *Environment {
	env := &Environment{
		Name:    name,
		Kind:    provider,
		Recipes: ".radius/recipes.yaml",
	}

	// Add cloud provider configuration placeholder
	switch provider {
	case ProviderKindAWS:
		env.Provider = ProviderConfig{
			AWS: &AWSProviderConfig{
				// Placeholders to be filled by rad environment connect
				AccountID:           "",
				Region:              "",
				OIDCRoleARN:         "",
				EKSClusterName:      "<EKS_CLUSTER_NAME>",
				KubernetesNamespace: "<KUBE_NAMESPACE>",
			},
		}
	case ProviderKindAzure:
		env.Provider = ProviderConfig{
			Azure: &AzureProviderConfig{
				// Placeholders to be filled by rad environment connect
				SubscriptionID:      "",
				TenantID:            "",
				ClientID:            "",
				ResourceGroupName:   "",
				OIDCEnabled:         false,
				AKSClusterName:      "<AKS_CLUSTER_NAME>",
				KubernetesNamespace: "<KUBE_NAMESPACE>",
			},
		}
	}

	return env
}
