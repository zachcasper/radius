/*
Copyright 2023 The Radius Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

// Workflow represents a GitHub Actions workflow.
type Workflow struct {
	Name        string                 `yaml:"name"`
	On          WorkflowTrigger        `yaml:"on"`
	Permissions map[string]string      `yaml:"permissions,omitempty"`
	Concurrency *WorkflowConcurrency   `yaml:"concurrency,omitempty"`
	Env         map[string]string      `yaml:"env,omitempty"`
	Jobs        map[string]WorkflowJob `yaml:"jobs"`
}

// WorkflowTrigger defines what triggers a workflow.
type WorkflowTrigger struct {
	Push             *PushTrigger             `yaml:"push,omitempty"`
	PullRequest      *PullRequestTrigger      `yaml:"pull_request,omitempty"`
	WorkflowDispatch *WorkflowDispatchTrigger `yaml:"workflow_dispatch,omitempty"`
}

// PushTrigger triggers on push events.
type PushTrigger struct {
	Branches []string `yaml:"branches,omitempty"`
	Paths    []string `yaml:"paths,omitempty"`
}

// PullRequestTrigger triggers on pull request events.
type PullRequestTrigger struct {
	Branches []string `yaml:"branches,omitempty"`
	Types    []string `yaml:"types,omitempty"`
}

// WorkflowDispatchTrigger allows manual triggering with inputs.
type WorkflowDispatchTrigger struct {
	Inputs map[string]WorkflowInput `yaml:"inputs,omitempty"`
}

// WorkflowInput defines an input for manual workflow dispatch.
type WorkflowInput struct {
	Description string   `yaml:"description"`
	Required    bool     `yaml:"required"`
	Default     string   `yaml:"default,omitempty"`
	Type        string   `yaml:"type,omitempty"`
	Options     []string `yaml:"options,omitempty"`
}

// WorkflowConcurrency controls concurrent workflow runs.
type WorkflowConcurrency struct {
	Group            string `yaml:"group"`
	CancelInProgress bool   `yaml:"cancel-in-progress,omitempty"`
}

// WorkflowJob represents a job in a workflow.
type WorkflowJob struct {
	Name        string            `yaml:"name,omitempty"`
	RunsOn      string            `yaml:"runs-on"`
	Permissions map[string]string `yaml:"permissions,omitempty"`
	Needs       []string          `yaml:"needs,omitempty"`
	If          string            `yaml:"if,omitempty"`
	Env         map[string]string `yaml:"env,omitempty"`
	Steps       []WorkflowStep    `yaml:"steps"`
}

// WorkflowStep represents a step in a job.
type WorkflowStep struct {
	Name            string            `yaml:"name,omitempty"`
	ID              string            `yaml:"id,omitempty"`
	Uses            string            `yaml:"uses,omitempty"`
	Run             string            `yaml:"run,omitempty"`
	With            map[string]string `yaml:"with,omitempty"`
	Env             map[string]string `yaml:"env,omitempty"`
	If              string            `yaml:"if,omitempty"`
	ContinueOnError bool              `yaml:"continue-on-error,omitempty"`
	WorkingDir      string            `yaml:"working-directory,omitempty"`
}

// SaveWorkflow writes a workflow to a YAML file.
func SaveWorkflow(filepath string, workflow *Workflow) error {
	data, err := yaml.Marshal(workflow)
	if err != nil {
		return fmt.Errorf("failed to marshal workflow: %w", err)
	}

	// Add header comment
	header := "# Radius deployment workflow\n# Generated by rad init - do not edit manually\n\n"
	data = append([]byte(header), data...)

	if err := os.WriteFile(filepath, data, 0644); err != nil {
		return fmt.Errorf("failed to write workflow: %w", err)
	}

	return nil
}

// LoadWorkflow reads a workflow from a YAML file.
func LoadWorkflow(filepath string) (*Workflow, error) {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read workflow: %w", err)
	}

	var workflow Workflow
	if err := yaml.Unmarshal(data, &workflow); err != nil {
		return nil, fmt.Errorf("failed to parse workflow: %w", err)
	}

	return &workflow, nil
}

// GenerateDeployWorkflow creates the deployment workflow template.
func GenerateDeployWorkflow(provider string) *Workflow {
	workflow := &Workflow{
		Name: "Radius Deploy",
		On: WorkflowTrigger{
			PullRequest: &PullRequestTrigger{
				Branches: []string{"main"},
				Types:    []string{"closed"},
			},
		},
		Permissions: map[string]string{
			"id-token": "write",
			"contents": "write",
		},
		Concurrency: &WorkflowConcurrency{
			Group:            "radius-deploy-${{ github.event.pull_request.head.ref }}",
			CancelInProgress: false,
		},
		Jobs: map[string]WorkflowJob{
			"deploy": {
				Name:   "Deploy",
				RunsOn: "ubuntu-latest",
				If:     "github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'deploy/')",
				Steps:  generateDeploySteps(provider),
			},
		},
	}

	return workflow
}

// GenerateDestroyWorkflow creates the destruction workflow template.
func GenerateDestroyWorkflow(provider string) *Workflow {
	workflow := &Workflow{
		Name: "Radius Destroy",
		On: WorkflowTrigger{
			PullRequest: &PullRequestTrigger{
				Branches: []string{"main"},
				Types:    []string{"closed"},
			},
		},
		Permissions: map[string]string{
			"id-token": "write",
			"contents": "write",
		},
		Jobs: map[string]WorkflowJob{
			"destroy": {
				Name:   "Destroy",
				RunsOn: "ubuntu-latest",
				If:     "github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'destroy/')",
				Steps:  generateDestroySteps(provider),
			},
		},
	}

	return workflow
}

// GeneratePlanWorkflow creates the plan workflow template for workflow_dispatch.
func GeneratePlanWorkflow(provider string) *Workflow {
	workflow := &Workflow{
		Name: "Radius Plan",
		On: WorkflowTrigger{
			WorkflowDispatch: &WorkflowDispatchTrigger{
				Inputs: map[string]WorkflowInput{
					"environment": {
						Description: "Target environment name",
						Required:    true,
						Type:        "string",
					},
					"application": {
						Description: "Application name (leave empty for all)",
						Required:    false,
						Type:        "string",
					},
				},
			},
		},
		Permissions: map[string]string{
			"id-token":      "write",
			"contents":      "write",
			"pull-requests": "write",
		},
		Jobs: map[string]WorkflowJob{
			"plan": {
				Name:   "Generate Plan",
				RunsOn: "ubuntu-latest",
				Steps:  generatePlanSteps(provider),
			},
		},
	}

	return workflow
}

func generateDeploySteps(provider string) []WorkflowStep {
	steps := []WorkflowStep{
		{
			Name: "Checkout",
			Uses: "actions/checkout@v4",
		},
		{
			Name: "Set up k3d",
			Uses: "abhinavsingh/setup-k3d@v1",
			With: map[string]string{
				"k3d-install-as": "local",
			},
		},
		{
			Name: "Create k3d cluster",
			Run:  "k3d cluster create radius-ephemeral --volume $GITHUB_WORKSPACE:/github_workspace",
		},
		{
			Name: "Install Radius CLI",
			Run:  "curl -fsSL https://get.radapp.io/tools/rad/install.sh | bash",
		},
	}

	// Add cloud-specific authentication
	if provider == "aws" {
		steps = append(steps, WorkflowStep{
			Name: "Configure AWS credentials",
			Uses: "aws-actions/configure-aws-credentials@v4",
			With: map[string]string{
				"role-to-assume": "${{ secrets.AWS_OIDC_ROLE_ARN }}",
				"aws-region":     "${{ secrets.AWS_REGION }}",
			},
		})
	} else if provider == "azure" {
		steps = append(steps, WorkflowStep{
			Name: "Azure Login",
			Uses: "azure/login@v2",
			With: map[string]string{
				"client-id":       "${{ secrets.AZURE_CLIENT_ID }}",
				"tenant-id":       "${{ secrets.AZURE_TENANT_ID }}",
				"subscription-id": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
			},
		})
	}

	// Add deployment step
	steps = append(steps, WorkflowStep{
		Name: "Run deployment",
		Run:  "rad deploy --plan-file .radius/plan/*/plan.yaml",
		Env: map[string]string{
			"KUBECONFIG": "/etc/rancher/k3d/kubeconfig-radius-ephemeral.yaml",
		},
	})

	// Add commit results step
	steps = append(steps, WorkflowStep{
		Name: "Commit deployment results",
		Run: `git config user.name "github-actions[bot]"
git config user.email "github-actions[bot]@users.noreply.github.com"
git add .radius/deploy/
git commit -m "Record deployment results" --trailer "Radius-Action: deploy" || true
git push`,
	})

	return steps
}

func generateDestroySteps(provider string) []WorkflowStep {
	steps := []WorkflowStep{
		{
			Name: "Checkout",
			Uses: "actions/checkout@v4",
		},
		{
			Name: "Set up k3d",
			Uses: "abhinavsingh/setup-k3d@v1",
			With: map[string]string{
				"k3d-install-as": "local",
			},
		},
		{
			Name: "Create k3d cluster",
			Run:  "k3d cluster create radius-ephemeral --volume $GITHUB_WORKSPACE:/github_workspace",
		},
		{
			Name: "Install Radius CLI",
			Run:  "curl -fsSL https://get.radapp.io/tools/rad/install.sh | bash",
		},
	}

	// Add cloud-specific authentication (same as deploy)
	if provider == "aws" {
		steps = append(steps, WorkflowStep{
			Name: "Configure AWS credentials",
			Uses: "aws-actions/configure-aws-credentials@v4",
			With: map[string]string{
				"role-to-assume": "${{ secrets.AWS_OIDC_ROLE_ARN }}",
				"aws-region":     "${{ secrets.AWS_REGION }}",
			},
		})
	} else if provider == "azure" {
		steps = append(steps, WorkflowStep{
			Name: "Azure Login",
			Uses: "azure/login@v2",
			With: map[string]string{
				"client-id":       "${{ secrets.AZURE_CLIENT_ID }}",
				"tenant-id":       "${{ secrets.AZURE_TENANT_ID }}",
				"subscription-id": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
			},
		})
	}

	// Add destroy step
	steps = append(steps, WorkflowStep{
		Name: "Run destruction",
		Run:  "rad destroy --plan-file .radius/plan/*/plan.yaml",
		Env: map[string]string{
			"KUBECONFIG": "/etc/rancher/k3d/kubeconfig-radius-ephemeral.yaml",
		},
	})

	// Add commit results step
	steps = append(steps, WorkflowStep{
		Name: "Commit destruction results",
		Run: `git config user.name "github-actions[bot]"
git config user.email "github-actions[bot]@users.noreply.github.com"
git add .radius/deploy/
git commit -m "Record destruction results" --trailer "Radius-Action: destroy" || true
git push`,
	})

	return steps
}

func generatePlanSteps(provider string) []WorkflowStep {
	steps := []WorkflowStep{
		{
			Name: "Checkout",
			Uses: "actions/checkout@v4",
		},
		{
			Name: "Set up k3d",
			Uses: "abhinavsingh/setup-k3d@v1",
			With: map[string]string{
				"k3d-install-as": "local",
			},
		},
		{
			Name: "Create k3d cluster",
			Run:  "k3d cluster create radius-ephemeral --volume $GITHUB_WORKSPACE:/github_workspace",
		},
		{
			Name: "Install Radius CLI",
			Run:  "curl -fsSL https://get.radapp.io/tools/rad/install.sh | bash",
		},
		{
			Name: "Install Radius control plane",
			Run:  "rad install kubernetes --set global.repositoryPath=.radius",
			Env: map[string]string{
				"KUBECONFIG": "/etc/rancher/k3d/kubeconfig-radius-ephemeral.yaml",
			},
		},
	}

	// Add cloud-specific authentication
	if provider == "aws" {
		steps = append(steps, WorkflowStep{
			Name: "Configure AWS credentials",
			Uses: "aws-actions/configure-aws-credentials@v4",
			With: map[string]string{
				"role-to-assume": "${{ secrets.AWS_OIDC_ROLE_ARN }}",
				"aws-region":     "${{ secrets.AWS_REGION }}",
			},
		})
	} else if provider == "azure" {
		steps = append(steps, WorkflowStep{
			Name: "Azure Login",
			Uses: "azure/login@v2",
			With: map[string]string{
				"client-id":       "${{ secrets.AZURE_CLIENT_ID }}",
				"tenant-id":       "${{ secrets.AZURE_TENANT_ID }}",
				"subscription-id": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
			},
		})
	}

	// Generate plan
	steps = append(steps, WorkflowStep{
		Name: "Generate deployment plan",
		Run:  "rad plan deploy --environment ${{ github.event.inputs.environment }} --application \"${{ github.event.inputs.application }}\"",
		Env: map[string]string{
			"KUBECONFIG": "/etc/rancher/k3d/kubeconfig-radius-ephemeral.yaml",
		},
	})

	// Create branch and PR
	steps = append(steps, WorkflowStep{
		Name: "Create deployment PR",
		Run: `BRANCH_NAME="deploy/${{ github.event.inputs.application || 'all' }}/${{ github.event.inputs.environment }}-$(date +%Y%m%d%H%M%S)"
git config user.name "github-actions[bot]"
git config user.email "github-actions[bot]@users.noreply.github.com"
git checkout -b "$BRANCH_NAME"
git add .radius/plan/
git commit -m "Deployment plan for ${{ github.event.inputs.environment }}" --trailer "Radius-Action: plan"
git push --set-upstream origin "$BRANCH_NAME"
gh pr create --title "Deploy to ${{ github.event.inputs.environment }}" --body "This PR contains the deployment plan for environment **${{ github.event.inputs.environment }}**." --base main --head "$BRANCH_NAME"`,
		Env: map[string]string{
			"GH_TOKEN": "${{ github.token }}",
		},
	})

	return steps
}

// GenerateAuthTestWorkflow creates the OIDC authentication test workflow.
// FR-031-A: Creates .github/workflows/radius-auth-test.yaml
// FR-031-B: Triggered by push events modifying .radius/env.*.yaml files
func GenerateAuthTestWorkflow(provider string) *Workflow {
	workflow := &Workflow{
		Name: "Radius Auth Test",
		On: WorkflowTrigger{
			Push: &PushTrigger{
				Paths: []string{".radius/env.*.yaml"},
			},
		},
		Permissions: map[string]string{
			"id-token": "write",
			"contents": "read",
		},
		Jobs: map[string]WorkflowJob{},
	}

	// Add provider-specific auth test job
	if provider == "aws" {
		workflow.Jobs["test-aws-auth"] = WorkflowJob{
			Name:   "Test AWS OIDC Authentication",
			RunsOn: "ubuntu-latest",
			Steps:  generateAWSAuthTestSteps(),
		}
	} else if provider == "azure" {
		workflow.Jobs["test-azure-auth"] = WorkflowJob{
			Name:   "Test Azure OIDC Authentication",
			RunsOn: "ubuntu-latest",
			Steps:  generateAzureAuthTestSteps(),
		}
	}

	return workflow
}

// generateAWSAuthTestSteps creates steps for testing AWS OIDC authentication.
// FR-031-C: Verify OIDC auth by calling aws sts get-caller-identity
func generateAWSAuthTestSteps() []WorkflowStep {
	return []WorkflowStep{
		{
			Name: "Checkout",
			Uses: "actions/checkout@v4",
			With: map[string]string{
				"fetch-depth": "2", // Need history for git diff
			},
		},
		{
			Name: "Parse environment config",
			ID:   "env",
			Run: `# Find the environment file - try git diff first, then fallback to listing
ENV_FILE=""
if git rev-parse HEAD~1 >/dev/null 2>&1; then
  ENV_FILE=$(git diff --name-only HEAD~1 HEAD | grep -F '.radius/env.' | grep '\.yaml$' | head -1)
fi
if [ -z "$ENV_FILE" ]; then
  ENV_FILE=$(find .radius -name 'env.*.yaml' 2>/dev/null | head -1)
fi

if [ -z "$ENV_FILE" ]; then
  echo "Error: No environment file found in .radius/"
  exit 1
fi
echo "Using environment file: $ENV_FILE"

# Parse AWS configuration using yq
ROLE_ARN=$(yq -e '.provider.aws.oidcRoleARN // ""' "$ENV_FILE" 2>/dev/null || echo "")
REGION=$(yq -e '.provider.aws.region // ""' "$ENV_FILE" 2>/dev/null || echo "")
BUCKET=$(yq -e '.provider.aws.stateBackend.bucket // ""' "$ENV_FILE" 2>/dev/null || echo "")

# Debug output
echo "Parsed values from $ENV_FILE:"
echo "  role-arn: ${ROLE_ARN:0:20}***"
echo "  region: $REGION"

# Validate required fields
if [ -z "$ROLE_ARN" ] || [ "$ROLE_ARN" = "null" ]; then
  echo "Error: oidcRoleARN not found in environment file"
  exit 1
fi
if [ -z "$REGION" ] || [ "$REGION" = "null" ]; then
  echo "Error: region not found in environment file"
  exit 1
fi

echo "role-arn=$ROLE_ARN" >> $GITHUB_OUTPUT
echo "region=$REGION" >> $GITHUB_OUTPUT
echo "bucket=$BUCKET" >> $GITHUB_OUTPUT`,
		},
		{
			Name: "Configure AWS credentials via OIDC",
			Uses: "aws-actions/configure-aws-credentials@v4",
			With: map[string]string{
				"role-to-assume": "${{ steps.env.outputs.role-arn }}",
				"aws-region":     "${{ steps.env.outputs.region }}",
			},
		},
		{
			Name: "Verify AWS authentication",
			Run: `echo "Testing AWS OIDC authentication..."
IDENTITY=$(aws sts get-caller-identity --output json)
echo "✅ AWS OIDC authentication successful!"
echo "Account: $(echo $IDENTITY | jq -r '.Account')"
echo "ARN: $(echo $IDENTITY | jq -r '.Arn')"`,
		},
		{
			Name: "Test S3 state backend access",
			If:   "steps.env.outputs.bucket != ''",
			Run: `echo "Testing Terraform state backend access..."
if aws s3 ls "s3://${{ steps.env.outputs.bucket }}" &>/dev/null; then
  echo "✅ S3 state bucket accessible"
else
  echo "⚠️ S3 state bucket not accessible (may not exist yet)"
fi`,
			ContinueOnError: true,
		},
	}
}

// generateAzureAuthTestSteps creates steps for testing Azure OIDC authentication.
// FR-031-D: Verify OIDC auth by calling az account show
func generateAzureAuthTestSteps() []WorkflowStep {
	return []WorkflowStep{
		{
			Name: "Checkout",
			Uses: "actions/checkout@v4",
			With: map[string]string{
				"fetch-depth": "2", // Need history for git diff
			},
		},
		{
			Name: "Parse environment config",
			ID:   "env",
			Run: `# Find the environment file - try git diff first, then fallback to listing
ENV_FILE=""
if git rev-parse HEAD~1 >/dev/null 2>&1; then
  ENV_FILE=$(git diff --name-only HEAD~1 HEAD | grep -F '.radius/env.' | grep '\.yaml$' | head -1)
fi
if [ -z "$ENV_FILE" ]; then
  ENV_FILE=$(find .radius -name 'env.*.yaml' 2>/dev/null | head -1)
fi

if [ -z "$ENV_FILE" ]; then
  echo "Error: No environment file found in .radius/"
  exit 1
fi
echo "Using environment file: $ENV_FILE"

# Parse Azure configuration using yq
CLIENT_ID=$(yq -e '.provider.azure.clientId // ""' "$ENV_FILE" 2>/dev/null || echo "")
TENANT_ID=$(yq -e '.provider.azure.tenantId // ""' "$ENV_FILE" 2>/dev/null || echo "")
SUBSCRIPTION_ID=$(yq -e '.provider.azure.subscriptionId // ""' "$ENV_FILE" 2>/dev/null || echo "")
STORAGE_ACCOUNT=$(yq -e '.provider.azure.stateBackend.storageAccountName // ""' "$ENV_FILE" 2>/dev/null || echo "")

# Debug output
echo "Parsed values from $ENV_FILE:"
echo "  client-id: ${CLIENT_ID:0:8}***"
echo "  tenant-id: ${TENANT_ID:0:8}***"
echo "  subscription-id: ${SUBSCRIPTION_ID:0:8}***"

# Validate required fields
if [ -z "$CLIENT_ID" ] || [ "$CLIENT_ID" = "null" ]; then
  echo "Error: clientId not found in environment file"
  exit 1
fi
if [ -z "$TENANT_ID" ] || [ "$TENANT_ID" = "null" ]; then
  echo "Error: tenantId not found in environment file"
  exit 1
fi
if [ -z "$SUBSCRIPTION_ID" ] || [ "$SUBSCRIPTION_ID" = "null" ]; then
  echo "Error: subscriptionId not found in environment file"
  exit 1
fi

echo "client-id=$CLIENT_ID" >> $GITHUB_OUTPUT
echo "tenant-id=$TENANT_ID" >> $GITHUB_OUTPUT
echo "subscription-id=$SUBSCRIPTION_ID" >> $GITHUB_OUTPUT
echo "storage-account=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT`,
		},
		{
			Name: "Configure Azure credentials via OIDC",
			Uses: "azure/login@v2",
			With: map[string]string{
				"client-id":       "${{ steps.env.outputs.client-id }}",
				"tenant-id":       "${{ steps.env.outputs.tenant-id }}",
				"subscription-id": "${{ steps.env.outputs.subscription-id }}",
			},
		},
		{
			Name: "Verify Azure authentication",
			Run: `echo "Testing Azure OIDC authentication..."
ACCOUNT=$(az account show --output json)
echo "✅ Azure OIDC authentication successful!"
echo "Subscription: $(echo $ACCOUNT | jq -r '.name')"
echo "Tenant: $(echo $ACCOUNT | jq -r '.tenantId')"`,
		},
		{
			Name: "Test Storage state backend access",
			If:   "steps.env.outputs.storage-account != ''",
			Run: `echo "Testing Terraform state backend access..."
if az storage account show --name "${{ steps.env.outputs.storage-account }}" &>/dev/null; then
  echo "✅ Azure Storage account accessible"
else
  echo "⚠️ Azure Storage account not accessible (may not exist yet)"
fi`,
			ContinueOnError: true,
		},
	}
}
